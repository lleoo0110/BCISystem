classdef CNNClassifier < handle
    properties (Access = private)
        params              % パラメータ設定
        net                 % CNNネットワーク
        lstmNet            % LSTMネットワーク 
        adaBoostModel      % AdaBoostモデル
        isEnabled          % 有効/無効フラグ
        isInitialized      % 初期化フラグ
    end
    
    properties (Access = public)
        performance        % 性能評価指標
    end
    
    methods (Access = public)
        function obj = CNNClassifier(params)
            obj.params = params;
            obj.isEnabled = params.classifier.cnn.enable;
            
            % 初期化
            fprintf('Initializing CNN Classifier...\n');
            if isfield(params.classifier.cnn, 'architecture')
                fprintf('Architecture Configuration Found\n');
            else
                fprintf('Using Default Architecture Configuration\n');
            end
            obj.isInitialized = false;
        end

        function results = trainCNN(obj, processedData, processedLabel)
            if ~obj.isEnabled
                error('CNN is disabled in configuration');
            end

            try
                fprintf('\n=== Starting CNN Training ===\n');
                
                % エポック数とデータサイズの表示
                fprintf('Input data size: [%s]\n', num2str(size(processedData)));
                fprintf('Label size: [%s]\n', num2str(size(processedLabel)));
                fprintf('Unique labels: %s\n', num2str(unique(processedLabel)'));
                
                % データの準備
                [trainData, trainLabels] = obj.prepareTrainingData(processedData, processedLabel);
                
                % CNNモデルの構築と学習
                fprintf('\nBuilding and Training CNN Model...\n');
                [cnnModel, cnnInfo] = obj.trainCNNModel(trainData, trainLabels);
                obj.net = cnnModel;
                
                % 性能評価
                obj.evaluatePerformance(trainData, trainLabels);

                % 結果の保存
                results = struct(...
                    'performance', obj.performance, ...
                    'model', obj.net, ...
                    'trainingInfo', cnnInfo ...
                );
                
                fprintf('Training completed successfully\n');
                obj.displayResults();

            catch ME
                fprintf('\n=== Error in CNN Training ===\n');
                fprintf('Error message: %s\n', ME.message);
                rethrow(ME);
            end
        end
        
        function [label, score] = predictOnline(obj, data, ~)
            if ~obj.isEnabled
                error('CNN is disabled');
            end

            try
                % データの前処理
                predictData = obj.prepareOnlineData(data);

                % モデルの検証
                obj.validateModel();

                % CNNによる予測
                [label, scores] = classify(obj.net, predictData);

                % クラス1（安静状態）の確率を取得
                score = scores(:,1);

            catch ME
                fprintf('Error in online prediction: %s\n', ME.message);
                rethrow(ME);
            end
        end
    end
    
    methods (Access = private)
        function [trainData, trainLabels] = prepareTrainingData(~, processedData, processedLabel)
            try
                % データサイズの出力
                fprintf('Original data size: [%s]\n', num2str(size(processedData)));
                fprintf('Original label size: [%s]\n', num2str(size(processedLabel)));

                % 3次元データの場合、4次元に変換 [channels x samples x 1 x trials]
                if ndims(processedData) == 3
                    [channels, samples, trials] = size(processedData);
                    trainData = reshape(processedData, [channels, samples, 1, trials]);
                else
                    % 2次元データの場合は3次元に変換後、4次元に
                    [channels, samples] = size(processedData);
                    trainData = reshape(processedData, [channels, samples, 1, 1]);
                end

                % ラベルをcategoricalに変換
                trainLabels = categorical(processedLabel);

                % 変換後のサイズを出力
                fprintf('Prepared data size: [%s]\n', num2str(size(trainData)));
                fprintf('Prepared labels size: [%s]\n', num2str(size(trainLabels)));

            catch ME
                error('Data preparation failed: %s\nTrace: %s', ME.message, getReport(ME));
            end
        end

        function [model, trainInfo] = trainCNNModel(obj, trainData, trainLabels)
            try
                % 検証パラメータの取得
                validationRatio = obj.params.classifier.cnn.training.validation.ratio;
                validationFreq = obj.params.classifier.cnn.training.validation.frequency;
                validationPatience = obj.params.classifier.cnn.training.validation.patience;

                % パラメータの妥当性チェック
                if ~isscalar(validationFreq) || ~isscalar(validationPatience)
                    error('Validation frequency and patience must be scalar values');
                end

                % データ分割のログ出力
                fprintf('Validation split ratio: %.2f\n', validationRatio);
                fprintf('Validation frequency: %d\n', validationFreq);
                fprintf('Validation patience: %d\n', validationPatience);

                % 検証データの分割
                numValidation = floor(size(trainData, 4) * validationRatio);

                % インデックスのランダムな並び替え
                indices = randperm(size(trainData, 4));
                validationIndices = indices(1:numValidation);
                trainingIndices = indices(numValidation+1:end);

                % 検証データの準備
                validationData = trainData(:,:,:,validationIndices);
                validationLabels = trainLabels(validationIndices);

                % モニタリング設定の取得
                monitoring = obj.params.classifier.cnn.training.monitoring;

                % プロット設定の決定
                plotSetting = 'training-progress';
                if ~monitoring.plot_training
                    plotSetting = 'none';
                end

                % Early Stopping用のOutputFcn
                bestValAccuracy = 0;
                patience = validationPatience;
                patienceCounter = 0;

                outputFcn = @(info)stopIfValidationAccuracyStops(info, ...
                    bestValAccuracy, patience, patienceCounter);

                % 学習オプションの設定
                options = trainingOptions('adam', ...
                    'InitialLearnRate', obj.params.classifier.cnn.training.initialLearnRate, ...
                    'MaxEpochs', obj.params.classifier.cnn.training.maxEpochs, ...
                    'MiniBatchSize', obj.params.classifier.cnn.training.miniBatchSize, ...
                    'ValidationData', {validationData, validationLabels}, ...
                    'ValidationFrequency', validationFreq, ...
                    'ValidationPatience', validationPatience, ...
                    'Shuffle', 'every-epoch', ...
                    'Verbose', true, ...
                    'OutputFcn', outputFcn, ...
                    'Plots', plotSetting);

                % レイヤーの構築
                layers = obj.buildCNNLayers();

                % モデルの学習
                [model, trainInfo] = trainNetwork(trainData(:,:,:,trainingIndices), ...
                                                trainLabels(trainingIndices), ...
                                                layers, options);

                % 学習結果のログ出力
                fprintf('Training completed with:\n');
                fprintf('Final validation frequency: %d\n', validationFreq);
                fprintf('Final validation patience: %d\n', validationPatience);

            catch ME
                error('CNN training failed: %s', ME.message);
            end
        end

        function stop = stopIfValidationAccuracyStops(info, bestValAccuracy, patience, patienceCounter)
            stop = false;

            % 検証精度の取得
            if ~isempty(info.ValidationAccuracy)
                currentAccuracy = info.ValidationAccuracy;

                % 精度が改善した場合
                if currentAccuracy > bestValAccuracy
                    bestValAccuracy = currentAccuracy;
                    patienceCounter = 0;
                else
                    patienceCounter = patienceCounter + 1;
                end

                % patience回数を超えたら停止
                if patienceCounter >= patience
                    stop = true;
                    fprintf('Early stopping triggered. Best validation accuracy: %.2f%%\n', ...
                        bestValAccuracy);
                end
            end
        end

        function layers = buildCNNLayers(obj)
            % クラス数の取得
            numClasses = obj.params.classifier.cnn.architecture.numClasses;

            % 入力サイズの計算
            channels = obj.params.device.channelCount;
            samples = round(obj.params.signal.window.analysis * obj.params.device.sampleRate);

            % レイヤーの定義
            layers = [
                imageInputLayer([channels samples 1], 'Name', 'input', 'Normalization', 'none')

                convolution2dLayer([3 3], 16, 'Padding', 'same', 'Name', 'conv1')
                batchNormalizationLayer('Name', 'bn1')
                reluLayer('Name', 'relu1')
                maxPooling2dLayer(2, 'Stride', 2, 'Name', 'pool1')
                dropoutLayer(0.5, 'Name', 'drop1')

                convolution2dLayer([3 3], 32, 'Padding', 'same', 'Name', 'conv2')
                batchNormalizationLayer('Name', 'bn2')
                reluLayer('Name', 'relu2')
                maxPooling2dLayer(2, 'Stride', 2, 'Name', 'pool2')
                dropoutLayer(0.5, 'Name', 'drop2')

                fullyConnectedLayer(128, 'Name', 'fc1')
                reluLayer('Name', 'relu_fc1')
                dropoutLayer(0.5, 'Name', 'drop_fc1')

                fullyConnectedLayer(64, 'Name', 'fc2')
                reluLayer('Name', 'relu_fc2')
                dropoutLayer(0.5, 'Name', 'drop_fc2')

                fullyConnectedLayer(numClasses, 'Name', 'fc_out')
                softmaxLayer('Name', 'softmax')
                classificationLayer('Name', 'output')
            ];

            fprintf('Created CNN with input size [%d %d 1] and %d output classes\n', ...
                channels, samples, numClasses);
        end

        function predictData = prepareOnlineData(obj, data)
            try
                % データの形状を確認
                [channels, samples] = size(data);
                
                % チャネル数の検証
                if channels ~= obj.params.device.channelCount
                    error('Invalid number of channels. Expected %d, got %d', ...
                        obj.params.device.channelCount, channels);
                end
                
                % サンプル数の検証
                expectedSamples = round(obj.params.signal.window.analysis * obj.params.device.sampleRate);
                if samples ~= expectedSamples
                    error('Invalid number of samples. Expected %d, got %d', ...
                        expectedSamples, samples);
                end

                % CNNの入力形式に変換 [channels × samples × 1]
                predictData = reshape(data, [channels, samples, 1]);

                % データの正規化（もし必要な場合）
                if obj.params.signal.preprocessing.normalize.enable
                    predictData = (predictData - mean(predictData(:))) / std(predictData(:));
                end

            catch ME
                error('Data preparation failed: %s', ME.message);
            end
        end

        function evaluatePerformance(obj, testData, testLabels)
            % モデルの性能評価
            YPred = classify(obj.net, testData);
            obj.performance.accuracy = mean(YPred == testLabels);
            obj.performance.confusionMat = confusionmat(testLabels, YPred);
            
            % クラスごとの性能評価
            classes = unique(testLabels);
            for i = 1:length(classes)
                className = classes(i);
                classIdx = (testLabels == className);
                obj.performance.classwise(i).precision = ...
                    sum(YPred(classIdx) == className) / sum(YPred == className);
                obj.performance.classwise(i).recall = ...
                    sum(YPred(classIdx) == className) / sum(classIdx);
                obj.performance.classwise(i).f1score = ...
                    2 * (obj.performance.classwise(i).precision * obj.performance.classwise(i).recall) / ...
                    (obj.performance.classwise(i).precision + obj.performance.classwise(i).recall);
            end
        end

        function validateModel(obj)
            % モデルが学習済みかチェック
            if isempty(obj.net)
                error('CNN model is not trained. Please train the model first.');
            end
        end

        function displayResults(obj)
            fprintf('\n=== CNN Classification Results ===\n');
            fprintf('Overall Accuracy: %.2f%%\n', obj.performance.accuracy * 100);
            fprintf('\nConfusion Matrix:\n');
            disp(obj.performance.confusionMat);
            
            fprintf('\nClass-wise Performance:\n');
            for i = 1:length(obj.performance.classwise)
                fprintf('Class %d:\n', i);
                fprintf('  Precision: %.2f%%\n', obj.performance.classwise(i).precision * 100);
                fprintf('  Recall: %.2f%%\n', obj.performance.classwise(i).recall * 100);
                fprintf('  F1-Score: %.2f%%\n', obj.performance.classwise(i).f1score * 100);
            end
        end
    end
end