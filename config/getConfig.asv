function params = getConfig(deviceType, varargin)
    % 使用例：
    % params = getConfig('epocx');
    % params = getConfig('epocx', 'preset', 'motor_imagery');
    
    % 現在のファイルのディレクトリパスを取得
    currentDir = fileparts(mfilename('fullpath'));
    
    % プリセットディレクトリのパスを構築
    presetDir = fullfile(currentDir, 'presets');
    
    % プリセットパスが存在することを確認
    if ~exist(presetDir, 'dir')
        mkdir(presetDir);
    end
    
    % === 入力パーサー設定 ===
    p = inputParser;
    addRequired(p, 'deviceType', @(x) ischar(x) || isstring(x));
    addParameter(p, 'preset', 'default', @(x) ischar(x) || isstring(x));
    parse(p, deviceType, varargin{:});
    

    %% === 保存&読み込みパラメータ ===
    acquisition_params = struct(...
        'mode', 'online', ...     % 'offline' または 'online'
        'save', struct(...
            'enable', true, ...
            'name', 'takara', ...    % 保存名（実験名など）
            'path', './Experiment Data', ...  % 保存ディレクトリ
            'saveInterval', 60, ...  % 一時保存の間隔（秒）
            'fields', struct(...
                'params', true, ...           % 設定情報
                'rawData', true, ...           % 生脳波データ
                'labels', true, ...            % 刺激開始ラベル
                'processedData', true, ...     % 処理済みデータ
                'processedLabel', true, ...     % 処理済みラベル
                'cspFilters', true, ...         % cspフィルタ
                'cspFeatures', true, ...         % 特徴量
                'svmClassifier', true, ...       % 分類器
                'results', true, ...             % 結果
                'metadata', true ...            % メタデータ
            ) ...
        ), ...
        'load', struct(...
            'enable', true, ...
            'filename', '', ...   % 実行後にブラウザから読み込み
            'path', '', ...
            'fields', struct(...
                'params', true, ...           % 設定情報
                'rawData', true, ...           % 生脳波データ
                'labels', true, ...          % 刺激開始ラベル
                'processedData', true, ...     % 処理済みデータ
                'processedLabel', true, ...     % 処理済みラベル
                'cspFilters', true, ...         % CSPフィルタ
                'cspFeatures', true, ...         % CSP特徴量
                'svmClassifier', true, ...         % SVM分類器
                'results', true, ...             % 結果
                'metadata', true ...         % メタデータ
            ) ...
        ) ...
    );

   %% === LSLパラメータ ===
    lsl_params = struct(...
        'stream', struct(...
            'name', '', ...            % デバイスから設定
            'libraryPath', 'C:\Users\keita\Documents\LLEOO\MATLAB  Repogitory\labstreaminglayer', ...
            'type', 'EEG' ...
        ), ...
        'simulate', struct(...        % シミュレーションモード
            'enable', false, ...
            'signal', struct(...        % シミュレーション信号の設定
                'alpha', struct(...     % アルファ波設定
                    'freq', 10, ...     % 周波数 (Hz)
                    'amplitude', 10 ... % 振幅
                ), ...
                'beta', struct(...      % ベータ波設定
                    'freq', 20, ...     % 周波数 (Hz)
                    'amplitude', 5 ...  % 振幅
                ) ...
            ) ...
        ) ...
    );

    %% === UDP設定パラメータ ===
    trigger_mappings = {
        'Level2：開始', 1;
        'Level2：終了', 2;
        'Level4：開始', 1;
        'Level4：終了', 2;
        'Level1：開始', 1;
        'Level1：終了', 2;
        'Level1：開始', 1;
        'Level1：終了', 2;
        'Level1：開始', 1;
        'Level1：終了', 2;
    };

    % マッピング構造体の動的生成
    mapping_struct = struct();
    for i = 1:size(trigger_mappings, 1)
        field_name = sprintf('trigger%d', i);
        mapping_struct.(field_name) = struct(...
            'text', trigger_mappings{i,1}, ...
            'value', trigger_mappings{i,2} ...
        );
    end

    udp_params = struct(...
        'receive', struct(...
            'enable', true, ...
            'port', 12345, ...
            'address', '127.0.0.1', ...  % デフォルトはローカルホスト
            'bufferSize', 1024, ...
            'encoding', 'UTF-8', ...
            'triggers', struct(...
                'enabled', true, ...
                'mappings', mapping_struct, ...
                'defaultValue', 0 ...
            ) ...
        ), ...
        'send', struct(...
            'enabled', true, ...
            'port', 54321, ...
            'address', '192.168.100.75', ...  % デフォルトはローカルホスト      % '192.168.100.75'
            'bufferSize', 1024, ...
            'encoding', 'UTF-8' ...
        ) ...
    );

    %% === 信号処理パラメータ ===
    signal_params = struct(...
        'enable', true, ...
        'window', struct(...
            'analysis', 2.0, ...           % 解析ウィンドウサイズ（秒）
            'stimulus', 5.0, ...  
            'bufferSize', 15, ...     % バッファサイズ（秒）
            'updateBuffer', 1, ...       % バッファ更新間隔（秒）
            'step', [], ...                % 自動計算
            'updateInterval', [] ...       % 自動計算
        ), ...
        'epoch', struct(...
            'storageType', 'array', ...
            'overlap', 0.25, ...
            'baseline', [] ...
        ), ...
        'augmentation', struct(...
            'enabled', false, ...
            'numAugmentations', 4, ...
            'maxShiftRatio', 0.1, ...
            'noiseLevel', 0.05 ...
        ), ...
        'normalize', struct(...
            'enabled', true, ...
            'perEpoch', true, ...
            'method', 'zscore' ...
        ), ...
        'frequency', struct(...
            'min', 1, ...
            'max', 50, ...
            'bands', struct(...
                'delta', [1 4], ...
                'theta', [4 8], ...
                'alpha', [8 13], ...
                'beta',  [13 30], ...
                'gamma', [30 50] ...
            ) ...
        ), ...
        'filter', struct(...
            'notch', struct(...
                'enabled', false, ...
                'frequency', [50 60], ...
                'bandwidth', 2 ...
            ), ...
            'fir', struct(...
                'enabled', true, ...
                'scaledPassband', true, ...
                'filterOrder', 100, ...
                'designMethod', 'window', ...
                'windowType', 'hamming', ...
                'passbandRipple', 1, ...
                'stopbandAttenuation', 60 ...
            ) ...
        ) ...
    );

    %% === 特徴抽出用パラメータ ===
    feature_params = struct(...
        'standardize', true, ...
        'power', struct(...
            'enable', true, ...
            'method', 'welch', ...        % fft, welch, filter, wavelet, hilbert, bandpower
            'normalize', true, ...        % パワー値の正規化
            'freqBand', [8 13], ...      % 解析する周波数帯域
            'fft', struct(...             % FFT解析用パラメータ
                'windowType', 'hamming', ...
                'nfft', 512 ...
            ), ...
            'welch', struct(...           % Welch法用パラメータ
                'windowType', 'hamming', ...
                'windowLength', 256, ...
                'overlap', 0.5, ...
                'nfft', 512, ...
                'freqResolution', 0.5, ...
                'segmentNum', 8 ...
            ), ...
            'filter', struct(...          % フィルタリング用パラメータ
                'type', 'butter', ...
                'order', 4 ...
            ), ...
            'wavelet', struct(...         % Wavelet解析用パラメータ
                'type', 'morl', ...
                'scaleNum', 128 ...
            ), ...
            'hilbert', struct(...         % Hilbert変換用パラメータ
                'filterOrder', 4 ...
            ), ...
            'bands', struct(...
                'names', {{'delta', 'theta', 'alpha', 'beta', 'gamma'}}, ...  % セル配列として定義
                'delta', [0.5 4], ...
                'theta', [4 8], ...
                'alpha', [8 13], ...
                'beta',  [13 30], ...
                'gamma', [30 45] ...
            ) ...
        ), ...
        'faa', struct(...
            'enable', true ...
        ), ...
        'erd', struct(...
            'enable', false ...
        ), ...
        'csp', struct(...
            'enable', false, ...
            'storageType', 'array', ...
            'patterns', 7, ...
            'regularization', 0.05 ...
        ) ...
    );

    %% === 特徴分類用パラメータ ===
    classifier_params = struct(...
        'svm', struct(...
            'enable', false, ...
            'type', 'svm', ...
            'kernel', 'rbf', ...
            'optimize', true, ...
            'probability', true, ...
            'hyperparameters', struct(...
                'optimizer', 'gridsearch', ...
                'boxConstraint', [0.1, 1, 10, 100], ...
                'kernelScale', [0.1, 1, 10, 100] ...
            ) ...
        ), ...
        'evaluation', struct(...
            'enable', true, ...
            'method', 'kfold', ...
            'kfold', 5, ...
            'holdoutRatio', 0.2, ...
            'metrics', struct(...
                'accuracy', true, ...
                'precision', true, ...
                'recall', true, ...
                'f1score', true, ...
                'auc', true, ...
                'confusion', true ...
            ), ...
            'visualization', struct(...
                'enable', false, ...
                'confusionMatrix', true, ...
                'roc', true, ...
                'learningCurve', true, ...
                'featureImportance', true ...
            ) ...
        ) ...
    );

    %% === ディスプレイ用パラメータ ===
    gui_params = struct(...
        'display', struct(...
            'visualization', struct(...
            'refreshRate', 0.2, ...         % 表示更新レート（秒）
                'enable', struct(...
                    'rawData', true, ...       % 生データ表示の有効/無効
                    'processedData', true, ... % 処理済みデータ表示の有効/無効
                    'spectrum', true, ...      % スペクトル表示の有効/無効
                    'ersp', true ...          % ERSP表示の有効/無効
                ), ...
                'scale', struct(...
                    'auto', true, ...          % 自動スケーリング
                    'raw', [-100 100], ...     % 生データ表示範囲（μV）
                    'processed', [-50 50], ...  % 処理済みデータ表示範囲（μV）
                    'freq', [0 50], ...        % 周波数表示範囲（Hz）
                    'power', [0.01 100], ...   % パワー表示範囲（μV²/Hz）
                    'displaySeconds', 5 ...     % 表示時間窓（秒）
                ), ...
                'showBands', true, ...         % 周波数帯域の表示
                'ersp', struct(...
                    'scale', [-3 3], ...       % ERSPカラーマップ範囲（dB）
                    'time', [-1 2], ...        % ERSP時間範囲（秒）
                    'baseline', [-0.5 0], ...  % ベースライン期間（秒）
                    'freqRange', [1 50], ...   % 周波数範囲（Hz）
                    'numFreqs', 50, ...        % 周波数分割数
                    'method', 'wavelet', ...   % 解析手法（'wavelet' or 'stft'）
                    'colormap', struct(...
                        'type', 'jet', ...     % カラーマップタイプ（'jet', 'parula', 'hot', 'cool'）
                        'reverse', false, ...  % カラーマップ反転
                        'limit', 'sym', ...    % 'sym'（対称）または'abs'（絶対値）
                        'background', 'white' ...  % 背景色（'white' or 'black'）
                    ) ...
                ) ...
            ) ...
        ) ...
    );

    %% === パラメータの統合 ===
    params = struct();
    params.acquisition = acquisition_params;
    params.lsl = lsl_params;
    params.udp = udp_params;
    params.signal = signal_params;
    params.feature = feature_params;
    params.classifier = classifier_params;
    params.gui = gui_params;
    params.device = configureDevice(deviceType);

    % プリセットの適用
    if ~strcmp(p.Results.preset, 'default')
        try
            % 内蔵プリセットを読み込む
            preset = loadBuiltinPreset(p.Results.preset);
            params = mergeStructs(params, preset);
        catch ME
            error('Failed to load preset "%s": %s', p.Results.preset, ME.message);
        end
    end
end


%% === 補助関数 ===
function deviceConfig = configureDevice(deviceType)
    % デバイス設定
    switch lower(deviceType)
        case 'epocx'
            deviceConfig = struct(...
                'name', 'EPOCX', ...
                'channelCount', 14, ...
                'channelNum', [4:17], ...
                'channels', {{'AF3','F7','F3','FC5','T7','P7','O1','O2','P8','T8','FC6','F4','F8','AF4'}}, ...
                'sampleRate', 256, ...
                'resolution', 14, ...       % ビット数
                'reference', 'CMS/DRL', ... % リファレンス方式
                'streamName', 'EmotivDataStream-EEG' ...
            );
        case 'mn8'
            deviceConfig = struct(...
                'name', 'MN8', ...
                'channelCount', 2, ...
                'channels', {{'T7','T8'}}, ...
                'sampleRate', 128, ...
                'resolution', 8, ...       % ビット数
                'reference', 'CMS/DRL', ... % リファレンス方式
                'streamName', 'EmotivDataStream-EEG' ...
            );
        case 'openbci8'
            deviceConfig = struct(...
                'name', 'OpenBCI8', ...
                'channelCount', 8, ...
                'channels', {{'Fp1','Fp2','C3','C4','P7','P8','O1','O2'}}, ...
                'sampleRate', 250, ...
                'resolution', 24, ...
                'reference', 'SRB', ...
                'streamName', 'OpenBCIDataStream' ...
            );
        case 'openbci16'
            deviceConfig = struct(...
                'name', 'OpenBCI16', ...
                'channelCount', 8, ...
                'channels', {{'Fp1','Fp2','C3','C4','P7','P8','O1','O2'}}, ... % あとで追加予定
                'sampleRate', 125, ...
                'resolution', 24, ...
                'reference', 'SRB', ...
                'streamName', 'OpenBCIDataStream' ...
            );
        otherwise
            error('Unknown device type: %s', deviceType);
    end
end


function result = mergeStructs(orig, new)
    % 入力チェック
    if ~isstruct(orig) || ~isstruct(new)
        error('Both inputs must be structures');
    end
    
    % 元の構造体をコピー
    result = orig;
    fields = fieldnames(new);
    
    for i = 1:length(fields)
        field = fields{i};
        try
            if isfield(orig, field)
                if isstruct(new.(field)) && isstruct(orig.(field))
                    % 両方が構造体の場合は再帰的にマージ
                    result.(field) = mergeStructs(orig.(field), new.(field));
                elseif iscell(new.(field)) && iscell(orig.(field))
                    % 両方がセル配列の場合は新しい値で上書き
                    result.(field) = new.(field);
                elseif isnumeric(new.(field)) && isnumeric(orig.(field))
                    % 両方が数値の場合は新しい値で上書き
                    result.(field) = new.(field);
                else
                    % その他の場合も新しい値で上書き
                    result.(field) = new.(field);
                end
            else
                % フィールドが存在しない場合は新規追加
                result.(field) = new.(field);
            end
        catch ME
            warning('Error merging field %s: %s', field, ME.message);
        end
    end
end

function preset = loadBuiltinPreset(presetName)
    % 現在のファイルのディレクトリからの相対パスでプリセットディレクトリを取得
    currentDir = fileparts(mfilename('fullpath'));
    presetDir = fullfile(currentDir, 'presets');
    
    % プリセットファイルの完全パスを構築
    presetPath = fullfile(presetDir, [presetName '_preset.m']);
    
    % プリセットファイルの存在確認
    if ~exist(presetPath, 'file')
        error('Preset file "%s_preset.m" not found in presets directory', presetName);
    end
    
    % プリセットを読み込む
    preset = loadPresetFromFile(presetPath);
end

function preset = loadPresetFromFile(presetPath)
    try
        % ファイルパスの検証
        if ~exist(presetPath, 'file')
            error('Preset file not found: %s', presetPath);
        end
        
        % パスからファイル名を取得して関数として実行
        [~, funcName, ~] = fileparts(presetPath);
        
        % 一時的にプリセットのディレクトリをパスに追加
        presetDir = fileparts(presetPath);
        addpath(presetDir);
        
        try
            % 関数ハンドルを作成して実行
            fh = str2func(funcName);
            preset = fh();
        catch ME
            rmpath(presetDir);
            rethrow(ME);
        end
        
        % パスから削除
        rmpath(presetDir);
        
        % プリセットの検証
        validatePreset(preset);
        
    catch ME
        error('Failed to load preset file: %s\nError: %s', presetPath, ME.message);
    end
end

function validatePreset(preset)
    requiredFields = {'signal', 'feature', 'classifier'};
    
    if ~isstruct(preset)
        error('Preset must be a structure');
    end
    
    for i = 1:length(requiredFields)
        if ~isfield(preset, requiredFields{i})
            error('Invalid preset structure: missing field ''%s''', requiredFields{i});
        end
        if ~isstruct(preset.(requiredFields{i}))
            error('Field ''%s'' must be a structure', requiredFields{i});
        end
    end
end